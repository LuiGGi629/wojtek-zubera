{
  
    
        "post0": {
            "title": "Python Environment for Data Science",
            "content": "Python Environment . Interpreter . If you have programs that require different python versions or programs that depend on different versions of the same third-party module and you want to switch between those programs seamlessly? . Pyenv will help you doing that! . You can install Pyenv by . curl https://pyenv.run | bash . After that, add the following lines to your .bashrc (same for .zshrc) to have pyenv available in your terminal . export PATH=&quot;~/.pyenv/bin:$PATH&quot; eval &quot;$(pyenv init -)&quot; eval &quot;$(pyenv virtualenv-init -)&quot; . I had to restart my terminal afterwards . On Ubuntu install the following ones to not run into problems . sudo apt-get install build-essential libsqlite3-dev sqlite3 bzip2 libbz2-dev zlib1g-dev libssl-dev openssl libgdbm-dev libgdbm-compat-dev liblzma-dev libreadline-dev libncursesw5-dev libffi-dev uuid-dev . Now, to install a python interpreter just do . pyenv install VERSION_YOU_WOULD_LIKE_TO_INSTALL . You can list out all versions available via pyenv . pyenv install --list . To make it concrete, let’s install python 3.8.2 and make it your default global-interpreter . pyenv install 3.8.2 . pyenv global 3.8.2 . Dependency Management via poetry . The way the authors recommend installing poetry is . curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python . Another way is using pip and pyenv-virtualenv. . Create a virtual environment called tools that is based on 3.8.2 . pyenv virtualenv 3.8.2 tools . Install poetry into the tools virtual env . pyenv activate tools . python -m pip install poetry . Check installed poetry version . poetry --version . Leave the virtual env . pyenv deactivate . Add your tools virtual env to the globally available ones . pyenv global 3.8.2 tools . I had to restart my terminal afterwards . You can start using poetry . poetry --version . Before using poetry I recommend configuring it, such that it creates your project’s virtual environment in a .venv folder inside the project directory. . poetry config virtualenvs.in-project true . Initialze a new project . poetry new ml-project cd ml-project . Add modules and create virtual environment. . poetry add pandas --extras all . Consistent Formatting and Readability . We add black as a development dependency with --dev as we don&#39;t need it when it comes to production . poetry add --dev black . I’d rather maintain the recommended 79 character length. I just need to configure my pyproject.toml to line-length=79 and everything is all set. Here’s my .toml file for configuring black: . [tool.black] line-length = 79 include = &#39; .pyi?$&#39; exclude = &#39;&#39;&#39; /( .git | .hg | .mypy_cache | .tox | .venv | _build | buck-out | build | dist )/ &#39;&#39;&#39; . poetry add --dev flake8 . Insight of your project&#39;s dependencies . poetry show --tree poetry show --latest . In order for black to work nicely with flake8, we need to list down some error codes to ignore. tox.ini configuration below: . touch tox.ini . . # Flake8 Configuration [flake8] ignore = E203, D203, E266, E501, W503, F403, F401 exclude = .tox, .git, __pycache__, docs/source/conf.py, build, dist, tests/fixtures/*, *.pyc, *.egg-info, .cache, .eggs max-line-length = 79 max-complexity = 18 select = B,C,E,F,W,T4,B9 format = ${cyan}%(path)s${reset}:${yellow_bold}%(row)d${reset}:${green_bold}%(col)d${reset}: ${red_bold}%(code)s${reset} %(text)s . mypy Type-Correctness . Through type annotations, your code becomes better to understand, maintain, and less prone to errors. Why less prone to errors? Because you can statically check if the types of your variables and functions match the expected ones. . poetry add --dev mypy . Running mypy might create a lot of errors. You can configure it to only warn you about the things you are interested in. You do that by adding a mypy.ini file to your project and refer to the documentation for more details. . Pre-commit . Pre-commit is a tool that executes checks before you commit code to your repository. When those checks fail, your commit will be rejected. With that, your repository will never see not formatted code, or none type-checked one, or anything else depending on the checks you are going to include. . You can either install it directly into your project using poetry or install it on your local machine. I prefer the latter, as pre-commit is only used locally and not on a CI/CD server. In contrast, black and mypy should run on a CI/CD server, thus, it makes sense to add them to the project’s dev dependencies. Here is how one could install it making use of the already existing tool virtual environment. . Install pre-commit into the tools virtual env . pyenv activate tools . python -m pip install pre-commit . pyenv deactivate . pre-commit --version . To use it, you first need to add a config file called .pre-commit-config.yaml to the top-level folder of your project. In that file, you configure all the hooks that should run. . touch .pre-commit-config.yaml . . repos: - repo: https://github.com/psf/black rev: 20.8b1 hooks: - id: black language_version: python3.8 - repo: https://github.com/pre-commit/mirrors-mypy rev: v0.782 hooks: - id: mypy - repo: https://gitlab.com/pycqa/flake8 rev: 3.8.3 # pick a git hash / tag to point to hooks: - id: flake8 . In the top level folder run . pre-commit install . It is recommended to manually run pre-commit on all files as is it only touches the files that have been changed since the last commit. . pre-commit run --all --show-diff-on-failure . Now, the hooks will run on every commit. The black hook will not only check for formatting issues but also format the files accordingly. Whenever you add a new hook, so also at the very beginning, it is recommended to manually run pre-commit on all files as is it only touches the files that have been changed since the last commit . Results . So what we have is a pipeline that safeguards project against wrongly-formatted code &mdash; now we can focus on content. . Credits to: . Simon Hawe | LJ MIRANDA | .",
            "url": "https://luiggi629.github.io/wojtek-zubera/poetry/",
            "relUrl": "/poetry/",
            "date": " • Sep 8, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About me",
          "content": "Hi! I’m Wojtek, welcome to my page about hardest part of the job. I’m a former professional e-gamer, currently machine learning engineer. . When asked about the hardest part of the job, I reply it’s not machine learning, considering most our ML looks like: . from sklearn import Model Model.fit(features, target) predictions = model.predict(testing_features) . Instead, the hardest parts of data science are developing everything that occurs before and after modeling. Before we have: loading data from a database, feature engineering, data validation, and data processing pipelines (assuming our job starts after data is ingested). After we need to verify the results, set tasks to run automatically on a schedule, write results back to our database and send off webhooks to trigger other services. . I started this blog for two purposes: to write about what I’m learning, and to share my perspectives and reflections with others and my future self. The former reason function mainly to reinforce what I’m learning. Most of the blog posts are a living document(jupyter notebook), so I’ll come back and edit things. These are also informal posts, more of a quick brain dump than a work of art. To be honest, this is more of a journal than a blog, but I’ve chosen to make this public in the case of: . a) the content can help someone else . b) someone disagrees and we can have a discussion. . I appreciate feedback and constructive criticism. The best place to reach me is in the comments, or on LinkedIn .",
          "url": "https://luiggi629.github.io/wojtek-zubera/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://luiggi629.github.io/wojtek-zubera/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}